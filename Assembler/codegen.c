#include <stdio.h>
#include <stdlib.h>
#include "structs.h"

// Convert string to int regarudless of base
int toInt(char *string){
    // Get bbase of nput
    int base = 10;
    
    if (string[1] == 'x') base = 16;
    if (string[1] == 'o') base = 8;
    if (string[1] == 'b') base = 2;

    // Cut of 0x, 0b, 0o or whatever if necesarry
    int strStart = 0;
    if (base != 10) strStart = 2;
    char *trimmedStr = malloc(0);

    while(string[strStart] != '\0'){
        if (base == 10) {
            // Base 10 is clean copy
            trimmedStr = realloc(trimmedStr, strStart+1); 
            trimmedStr[strStart] = string[strStart];
        } else {
            // Other bases need first two chars trimmed
            trimmedStr = realloc(trimmedStr, strStart-1);
            trimmedStr[strStart-2] = string[strStart];
        }
        strStart++;
    }

    // return strtol
    return strtol(trimmedStr,NULL,base);
}

// Push a label to the label table
void addLabel (Label *lt, Label l, int *size){
    *size += 1;
    lt = realloc(lt, *size*sizeof(Label));
    if (lt == NULL) perror("COULDNT REALLOC LABEL TABLE");
    lt[*size-1] = l;
}

// Populates the label reference table and returns its size
int populateLabelTabel(Program *program, Label *labelTable){
    // Track address
    int address = 0;
    int labels = 0;

    // Find address of each instruction
    for (int i = 0; i < program->length; i++){
        Instruction *ins = &program->Instructions[i];
        switch (ins->instructionType) {
            case LABEL:
                // Labels dont change address, but they need their address recorded
                printf("Label %s found\n", ins->operands[0].value);
                Label l;
                l.address = address;
                l.identifier = ins->operands[0].value;
                addLabel(labelTable, l, &labels);
                printf("LABELS: %i\n",labels);
                break;

            case ORG:
                // ORG directly sets address
                address = toInt(++ins->operands[0].value);
                printf("Organized to %i\n", address);
                break;

            case GLOBAL:
                // Global doesnt affect address
                break;

            default:
                printf("UNKNOWN INSTRUCTION %i IN POPULATE LABEL TABLE\n", ins->instructionType);
                break;
        }
    }
}

// Generate output file from program generated by parser
int generateCode(Program *program, FILE *outFile){
    // Initialize table of labels
    Label *labelTable = malloc(0);
    int labelTabelSize = populateLabelTabel(program, labelTable);

    // Track address
    int address = 0;
    for (int i = 0; i < program->length; i++){
        Instruction *ins = &program->Instructions[i];
        switch (ins->instructionType) {
            case GLOBAL:
                printf("Global entrypoint found: %s\n", ins->operands[0].value);
                break;

            case ORG:
                address = toInt(++ins->operands[0].value);
                printf("Organized to %i\n", address);
                break;
            
            default:
                break;
        }
    }
    return 0;
}


