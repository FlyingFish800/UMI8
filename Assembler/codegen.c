#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include "structs.h"

// Size of 16bit address space
#define PROGRAM_SIZE 0x10000

// Convert string to int regarudless of base
int toInt(char *string){
    // Get bbase of nput
    int base = 10;
    
    if (string[1] == 'x') base = 16;
    if (string[1] == 'o') base = 8;
    if (string[1] == 'b') base = 2;

    // Cut of 0x, 0b, 0o or whatever if necesarry
    int strStart = 0;
    if (base != 10) strStart = 2;
    char *trimmedStr = malloc(0);

    while(string[strStart] != '\0'){
        if (base == 10) {
            // Base 10 is clean copy
            trimmedStr = realloc(trimmedStr, strStart+1); 
            trimmedStr[strStart] = string[strStart];
        } else {
            // Other bases need first two chars trimmed
            trimmedStr = realloc(trimmedStr, strStart-1);
            trimmedStr[strStart-2] = string[strStart];
        }
        strStart++;
    }

    // return strtol
    return strtol(trimmedStr,NULL,base);
}

// Push a label to the label table
int addLabel (LabelTable *lt, Label l){
    lt->length += 1;
    lt->labels = realloc(lt->labels, sizeof(Label)*lt->length);
    if (lt->labels == NULL) {perror("COULDNT REALLOC LABELS"); return 0;}
    lt->labels[lt->length-1] = l;
    return 0;
}

// Add instuction to instruction table array at a specific lcoation
int addInstructionToTable(char instruction, char* instructionTable, int address){
    // Resize to be at size of current address if it is larger than the current size
    if (address >= PROGRAM_SIZE) {printf("ADDRESS TOO LARGE 0x%x of %i\n", address, PROGRAM_SIZE); return -1;}
    instructionTable[address] = instruction;
    return 0;
}

// Generate output file from program generated by parser
int generateCode(Program *program, FILE *outFile){
    // Initialize table of labels and machine code
    LabelTable lt;
    lt.length = 0;
    lt.labels = malloc(0);
    char *machineCode = malloc(PROGRAM_SIZE);

    // One pass approach where code is generated, and labels are resolved at the end
    
    // Track address
    int address = 0;

    // Find address of each instruction
    for (int i = 0; i < program->length; i++){
        Instruction *ins = &program->Instructions[i];

        // Switch on instruction type
        switch (ins->instructionType) {
            case LABEL:
                // Labels dont change address, but they need their address recorded
                Label l;
                l.address = address;
                l.identifier = ins->operands[0].value;

                // Add label and handle errors if necessary
                if(addLabel(&lt, l) < 0) return -1;
                printf("label %i found '%s' @0x%x\n", lt.length, ins->operands[0].value, l.address);
                break;

            case ORG:
                // ORG directly sets address
                address = toInt(++ins->operands[0].value);
                printf("Organized to %i\n", address);
                break;

            case GLOBAL:
                printf("Global entrypoint found: %s\n", ins->operands[0].value);
                // Global doesnt affect address
                break;

            case LD:
                addInstructionToTable('L',machineCode, address);
                // Load can have variable length based on which variant is used. All should have 2 operands though
                if (ins->operandsLength != 2) {printf("INVALID OPERANDS LENGTH %i FOR LD\n", ins->operandsLength); return -1;}

                // Check to see which variant is used
                switch (ins->operands[0].accesingMode) {
                    case REGISTER: // LD reg, ?
                        /* code */
                        break;

                    default:
                        printf("INVALID/UNIMPLEMENTED OPERAND TYPE %i\n", ins->operands[0].accesingMode);
                        return -1;
                }
                address += 1;
                break;

            case NOP:
                // All these instructions are one byte with no args
                machineCode[address] = 0x0;
                address += 1;
                break;

            case RET:
                // All these instructions are one byte with no args
                machineCode[address] = 0x22;
                address += 1;
                break;

            default:
                printf("UNKNOWN INSTRUCTION %i IN POPULATE LABEL TABLE\n", ins->instructionType);
                return -1;
                break;
        }
    }

    // LABEL TABLE NOW POPULATED. RESOLVE INSTRUCTIONS THAT RELY ON LABELS

    printf("PRINTING LABEL TABLE:\n");
    for (int i = 0; i < lt.length; i++) {
        printf("%s 0x%x\n", lt.labels[i].identifier, lt.labels[i].address);
    }


    // Works, doesnt print NOP
    printf("MACHINE CODE:\n");
    for (int i = 0; i < PROGRAM_SIZE; i++)
    {
        if(machineCode[i] != 0) printf("%c",machineCode[i]);
    }

    printf("\n");
    

    return 0;
}